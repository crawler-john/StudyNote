一.虚拟内存
1.每个进程都有各自独立的4G虚拟地址空间
2.用户程序中使用的都是虚拟地址空间的地址，用户程序永远无法访问实际的物理内存地址
3.虚拟内存到物理内存的映射由操作系统维护
4.虚拟内存一方面保护了操作系统的安全，一方面允许应用程序使用比实际物理内存更大的统一的地址空间，极大方便管理
5.4G的地址空间分为2部分，0-3G是用户空间，3G-4G是内核空间
6.用户空间的代码不能直接访问内核空间的代码和数据，但是可以通过系统调用进入内核态，间接地与内核交互
7.对内存的越权访问，或者访问未建立映射的虚拟内存，会导致段错误
8.用户空间对应进程，进程一旦切换，用户空间会随之变化。内核空间由操作系统内核使用，不会随着进程切换而改变，内核空间有内核根据独立且唯一的页表init_mm.pgd进行映射。而用户空间的页表每个进程都有一份
9.每个进程的内存空间完全独立，因此不同进程之间交换虚拟地址毫无意义
10.标准库的内存分配函数(malloc/calloc/realloc)需要一套数据结构维护动态分配的内存，因此会分配比实际要求的内存多12个字节的内存，用来存储某些控制信息。该信息一旦被破坏，将导致后续操作，如free等出现异常
11.虚拟内存到物理内存的映射以页(4096字节)为单位，通过malloc函数首次分配内存，至少映射33页，即使通过free函数，释放掉全部动态分配的内存，最初的33页任然保留，直到进程退出时这33页才会被解除映射
#include <unistd.h>

int getpagesize(void);
//返回内存页的字节数
char *pc = malloc(sizeof(char));
	  |
	  |<-----------33页--------->|
----------+-----+--------+-------------------------|
	  |1字节|控制信息 |
------+---+-----+---------+-------------+-------------+
段错误    OK 	  后续错误    不稳定     段错误


二.内存管理API
void *sbrk(
intptr_t increment//内存增量(字节)
);
参数：
	increment取值：
	0：获取当前末尾指针
	>0:增加内存空间
	<0:释放内存空间
返回值：
	返回调整内存大小前的末尾指针，失败返回-1
	
系统内部维护一个指针，指向当前堆内存最后一个字节的下一个位置。
sbrk函数根据增量参数来调整该指针的位置，同时返回该指针调整之前的位置
若发现页耗尽或者页空闲，自动追加或解除页的映射

int brk(void *addr);
系统内部维护一个指针，指向当前堆内存最后一个字节的下一个位置。
参数：
	brk函数会根据addr参数设置内部指针的位置
返回值：
	成功返回0，失败返回-1

为了方便起见，我们通常使用sbrk分配内存，brk释放内存

cat /proc/$(pid)/maps

练习：使用sbrk/brk实现一个堆栈数据结构，存放整数
利用该堆栈实现一个任意进制打印整数的函数

自己实现一个简易的malloc

mmap函数
void *mmap(void *addr, //映射区的首地址，给NULL系统自动选择
	   size_t length, //映射区长度(字节)，按页取整
	   int prot, //映射的权限
	   int flags,//映射标识
          	 int fd, //文件描述符
	   off_t offset//文件偏移量
);
成功返回映射区首地址，失败返回(void *)-1
prot的取值:
       PROT_EXEC - 映射区可执行

       PROT_READ - 映射区可读

       PROT_WRITE - 映射区可写

       PROT_NONE - 映射区不可访问

flags取值：
	MAP_SHARED - 对映射区的写操作直接反映到文件中

	MAP_PRIVATE - 对映射区的写操作只反映到内存中，不进文件
	
	MAP_ANONYMOUS - 内存映射，将虚拟地址映射到物理内存中

	MAP_FIXED - 如果在addr无法创建映射，返回失败，无此标志地址会自			动调整

	MAP_DENYWRITE - 推荐不再使用,拒绝它对其他文件的写入

	MAP_LOCKED - 锁定映射区域


int munmap(void *addr,//映射区首地址
 	   size_t length//映射区长度,按页取整
);//解除映射
成功返回0，失败-1

系统调用：
mmap/munmap:底层不维护任何东西,只是返回一个建立映射的虚拟地址
brk/sbrk:底层维护一个指针，记录堆尾
C标准库函数
malloc/free:底层维护一个双向链表,存储内存块的控制信息


精灵进程/后台进程的编程方法
1.创建一个子进程，让父进程结束
2.关闭从父进程继承的文件描述符
3.成立自己的进程组
4.修改从父进程继承的权限屏蔽字
5.设置当前工作目录
//执行真正的服务工作





