一.设置信号处理方式的函数
typedef void (*sighandler_t)(int);
//给函数指针void (*)(int)类型起别名sighandler_t

sighandler_t signal(int signum, sighandler_t handler);
参数：
	参数signum就是被设置处理方式的信号
	第二个参数是一个函数指针,支持三种值：
	SIG_IGN - 表示忽略该信号
	SIG_DFL - 表示信号到来时执行默认处理方式
	自定义的函数 - 表示信号到来时执行自定义函数

返回值:
	返回之前的信号处理方式，出错返回SIG_ERR

自定义信号处理方式的步骤
1.写一个信号处理函数 格式 void fa(int){}
2.调用signal(int signum,fa)注册处理函数


父子进程的信号处理
如果父进程改变了信号的处理方式，子进程会如何？
fork()创建的子进程,与父进程的处理方式一致
vfork()+execl()创建的子进程,父进程忽略的，子进程忽略，父进程默认的，子进程默认，父进程自定义的，子进程默认

killall可以删除所有同名的进程，比如
killall a.out 就会删除所有名为a.out的进程

信号的发送：
1.用键盘发送信号
ctrl + c   -> 信号2
ctrl + \   -> 信号3
ctrl + z   -> 信号20

2.硬件故障/或者程序出错
段错误,总线错误,整数除以0

3.kill命令发送信号(全部)
kill -信号 进程ID

4.信号发送函数(全部)
kill()，raise(),alarm(),sigqueue()等

int kill(pid_t pid, int sig);
参数：
	pid就是发送哪个/那些进程,使用方式和waitpid(pid)一样
	sig就是发送哪个信号
返回值：
	成功返回0，失败返回-1	

发送信号时，一般pid都为整数，也就是发送给特定进程

alarm()函数
不是真正意义上的信号发送函数，而是过一段时间(秒数)发送特定信号

sleep()函数
让程序休眠一定的时间(秒数)，但是可能被非忽略的信号打断
返回值表示被打断时还剩余的休眠秒数
usleep()休眠一定的时间(微秒)

void *fa(int)		->	函数声明	
void (*fa)(int) 	->	函数指针

信号集和信号屏蔽
long long int - C语言中64位整型
多个信号可以存入信号集,类型sigset_t,可以看成一个超大型的整数

数据结构包括逻辑结构，物理结构和运算结构。逻辑结构表示逻辑上是怎样的(人脑中的定义)，物理结构就是内存如何组织的(计算机的底层实现)。运算结构就是需要对外提供什么函数(实现的功能)
运算结构包括：
1.创建和销毁函数
2.增加和删除元素
3.修改和查询元素
4.其他函数(遍历，排序)

信号集的函数：
1.增加信号和删除信号
2.查询信号
sigaddset() - 增加一个信号(把某位2进制位置1)
sigdelset() - 删除一个信号(把某位2进制位清0)
sigemptyset() - 删除全部信号
sigfillset() - 填满所有信号
sigismember() - 查询有没有某个信号


信号屏蔽
sigprocmask(...)










