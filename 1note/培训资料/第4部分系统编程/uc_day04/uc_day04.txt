一.
sprintf:往字符串中输入数据
fprintf:往文件中输入数据

读写文件用那一套函数？标C还是UC函数
如果考虑通用性，就使用标C函数,如果确定只在Unix/Linux下使用，UC的也行

time a.out可以查看a.out的运行时间

文件读写的位置用偏移量记录,在文件表中存储了偏移量。函数lseek()可以随意移动偏移量

off_t lseek(int fd, off_t offset, int whence);
参数：	fd就是文件描述符
	offset是偏移量
	whence是偏移的开始位置
返回值:	当前位置到文件头的偏移量,失败返回-1
whence + offset可以确定位置,whence包括
	SEEK_SET	文件头
	SEEK_CUR	当前位置
	SEEK_END	文件尾
我们可以利用lseek来计算文件的大小


二.文件操作的非读写函数
1.dup() dup2()---复制文件描述符,但不复制文件表
dup()由系统选定新的描述符的值，dup2()由程序员指定新的描述符的值，如果指定值已经被使用，先关闭在使用(不安全)

函数fcntl()实现很多功能,由参数cmd决定，常见的应用
1.可以复制文件描述符
2.可以设置/获取文件描述符的状态
3.可以设置文件锁

int fcntl(int fd, int cmd, ...);
参数：	fd是文件描述符
	cmd命令：可以设置fcntl()完成什么功能，常用的功能
	F_DUPFL (long):复制文件描述符,传入的第三个参数作为新描述符的值
		和dup2()的区别在于不会强行关闭已使用的文件描述符，而是寻找大于等于参数的最小未使用的值
	F_GETFL (void)/F_SETFD (long):获取/设置描述符的状态,比如权限,其中设置时,只对O_APPEND有效，权限和创建标识都无	效,获取时,只能获取权限和O_APPEND,，无法获取创建标识
	F_GETLK/F_SETLK/F_SETLKW:文件锁的操作

文件锁:
	当多个进程同时写一个文件时，有可能引发数据混乱，这种问题需要解决，解决方案包括：进程同步或者文件锁,文件锁就是当一个进程读写文件时，对其他进程进行读写限制
	结论：	一个进程读,允许其他进程读，不允许其他进程写
	      	一个进程写,其他进程不能读也不能写
		文件锁是一个读写锁,包括读锁和写锁
		读锁是一个共享锁,允许其他进程读(共享).如果进程是写文件，应该上写锁

fcntl(fd,cmd,...)
当cmd为F_SETLK/F_SETLKW时，可以对文件上锁
当使用文件锁时，第三个参数是结构体flock指针
struct flock {
               short l_type;//锁的类型
               short l_whence;//锁定的起始点的参考位置
               off_t l_start;//针对参考位置的偏移量
               off_t l_len;//锁定区间的长度
               pid_t l_pid;//只对F_SETLK有效，一般给-1

};
锁的类型包括: F_RDLCK(读锁),F_WRLCK(写锁), F_UNLCK(释放锁)
l_whence和l_start联合决定锁的起始点，比如l_whence选SEEK_SET,l_start选10，表示从头开始偏移10个字节开始锁

进程结束会自动释放锁,但是最好程序员自己释放

文件锁只是内存的一个标识,不会真正锁定文件,fcntl(F_SETLK)不能锁定read()/write()，智能锁定其他进程的加锁行为fcntl(F_SETLK)，文件锁的正确用法是：
在调用read()函数之前用fcntl()加读锁，能加上再读，读完以后释放锁，在调用write()之前用fcntl()加写锁，能加上再写，写完以后释放锁
fcntl(fd,F_SETLK,&读锁);
read(fd,...)
fcntl(fd,F_SETLK,&释放锁);
或者
fcntl(fd,F_SETLK,&写锁);
write(fd,...)
fcntl(fd,F_SETLK,&释放锁);

F_SETLK当锁加不上时,直接返回-1，F_SETLKW当锁加不上，会继续等待，等到能加上为止
F_GETLK不是获取当前的锁,而是测试一下锁能不能加上,并不是真正的加锁。(了解)

练习：再写一个写a.txt的程序进行测试

C语言里面函数参数分为3中
传入型参数：给函数传值,比如add(int,int)
传出型参数:带回函数的结果,一般是指针类型
传入传出参数：先传入一个值,再带出一个值
返回值和传出型参数都可以带回函数的值

stat()就是用传出型参数返回文件的信息
stat()可以取得文件的以下信息
ls -il的所有信息,其中最常用的是st_size
st_mode需要拆分，包括文件类型和权限

access()可以判定当前用户对文件的权限和文件是否存在
int access(const char *pathname, int mode);
参数pathname就是带路径的文件名
mode表示要判断什么
R_OK	-读权限
W_OK	-写权限
X_OK	-执行权限
F_OK	-文件是否存在
返回0表示有权限或者文件存在

其他函数
chmod()	-修改文件的权限
	chmod("a.txt",0666);
truncate()/ftruncate() -指定文件的大小
	truncate("a.txt",100);
remove() -删除文件，空目录
rename() -文件改名
umask() -创建文件时，系统默认的权限屏蔽字，默认屏蔽其他用户的写权限0022/0002，umask可以修改默认的权限屏蔽字
mode_t umask(mode_t);
传入新的屏蔽字，返回之前的屏蔽字，用于之后的恢复


目录相关函数
mkdir()		-新建一个目录
rmdir()		-删除一个空目录
chdir()		-切换当前目录(cd)
getcwd()	-返回当前目录的绝对路径
char *s = getcwd(0,0);

读目录的函数
opendir()	-打开一个目录，返回目录流(指针)
readdir()	-读目录的一个子项(子目录/子文件)
		类似于ls命令
closedir()	-关闭目录流

练习：写一个函数，打印出一个目录下的所有子文件(子目录下的也要打出来)
用递归


二.程序和进程
程序时代码编译的成品(a.out)，程序时硬盘上的文件
进程是运行在内存中的程序,一个程序可以启动多次，得到多个进程
CPU只能直接操作内存，不能直接操作硬盘,硬盘上的程序想要运行,先要加载到内存中去,就变成了进程

主流的操作系统都是多进程的,每个进程内部可以用多线程实现功能的并行(同时运行)。
进程的相关命令
ps:只能看到当前终端启动的程序
ps -aux:linux专用查看所有进程的命令,UNIX不直接支持
ps -ef：通用
kill -9 进程ID(pid)	杀死进程(发信号)

管道的用法
管道的作用是用前面的输出作为后面的输入
ps -ef | wc	-统计行数，字节数，单词数等
ls -al |more 	-分页显示(空格 回车 q)

Unix/linux系统由内核和shell，shell主要：sh/bash(sh的升级版)/csh

父子进程


