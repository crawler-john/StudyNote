父子进程
如果a进程启动了b进程,a就是父进程,b就是子进程。Unix/Linux系统的启动次序是系统	系统0进程，0进程启动进程1/系统启动进程1和进程2，其他进程都是由1和2启动

进程的状态
每个进程都有自己的状态
S - 休眠状态，大多数进程都处于休眠状态
s - 有子进程
R - 正在运行
Z - 僵尸进程(已经结束，但是资源没有回收)
T - 暂停或者被追踪

每个进程用进程ID(PID)作为唯一标识,进程PID是系统管理。函数getpid()可以取得进程的PID，PID可以重复使用,但是要延迟使用。PID唯一标识一个进程
getpid() -取当前进程的PID
getppid()-取父进程的PID
getuid() -取当前用户的ID


如何创建子进程
fork() - 非常复杂的简单函数，通过复制父进程产生子进程
vfork() + exec() - 不复制任何东西，创建一个全新的子进程

进程PID是pid_t类型，是一个非负整数
pid_t fork(),返回子进程的ID或者0，出错-1
fork()通过复制父进程的内存空间创建子进程,除了代码区父子进程共享，其他内存区域子进程都要复制
fork()创建子进程之后，父子进程同时运行,谁先运行不确定，谁先结束也不确定
fork()在复制父进程的内存空间时，如果遇到文件描述符,只会复制文件描述符不会复制文件表
fork()在复制父进程的内存空间时，也会复制输入/输出缓冲区
fork()函数调用一次，返回2次，父进程返回子进程ID，子进程返回0

关于父进程的运行和资源回收
父进程启动子进程后，父子进程同时运行，如果子进程先结束，会给父进程发信号，父进程负责回收子进程资源
父进程启动子进程后，父子进程同时运行，如果父进程先结束，子进程编程孤儿进程，认进程1(init)做新的父进程，init也叫孤儿院
父进程启动子进程后，父子进程同时运行，如果子进程没有给父进程发信号就结束，或者父进程没有及时处理信号，此时子进程变成僵尸进程

进程结束的方式分为正常结束和非正常结束
正常结束：
主函数中执行return
执行exit()
_Exit()和_exit()
所有线程都结束

非正常结束：
信号打断进程(ctrl+c kill -9)
最后一个线程被取消

exit()和_Exit(),_exit()的区别
_Exit()和_exit()基本无区别，都是立即退出进程
exit()不是立即退出，甚至可以先执行atexit()中注册的函数后在推出

函数wait()/waitpid()可以让父进程等待子进程结束,并取得子进程的退出状态和退出码(return或者exit(值))

pid_t wait(int *status)
    wait()函数让父进程等待任意一个子进程结束，并返回子进程的PID,把进程的退出状态和退出码存入status中，如果子进程没有结束，会阻塞父进程，直到有子进程结束为止，包括僵尸子进程，因此wait()也叫殓尸工

带参宏WIFEXITED(status)判断是否正常结束,WEXITSTATUS(status)可以获得退出码
