wait() = waitpid(-1,&status,0)
一.
waitpid()可以设置等待的方式和等待的子进程
pid_t waitpid(pid_t pid, int *status, int options);
参数：	pid可以指定等待哪个/哪些子进程
	status的用法和wait一样
	options为0，没有子进程结束就继续等待
	为WNOHANG，没有子进程结束不等待，直接返回0
	pid的值：
	-1:等待任意子进程,和wait()一样
	0:等待本组的子进程(与父进程同一个进程组)
	>0:等待子进程ID=pid的子进程
	<-1:等待进程组为[pid]的所有子进程
	注：-1和>0常用，其他两个了解

返回值有三种可能：
	结束子进程的ID
	-1表示出错
	0只有在在options为WNOHANG，同时没有子进程结束，也没有出错

二.
fork()父子进程使用相同的代码区，如果需要父子进程的代码区不同的话，可以使用vfork()+execl()
vfork()创建新的子进程,execl()负责提供子进程的代码和数据(程序)
execl()函数用新的程序替换原有的程序

vfork()从语法上和fork()完全一样,区别在于vfork()不复制父进程的任何资源,vfork()会抢占父进程的资源，导致父进程阻塞。
父进程解除阻塞的条件：
1 子进程结束时，归还父进程的资源(无并行)
2 子进程调用exec系列函数(execl等),也会归还父进程资源
注意：
vfork()会保证子进程先运行(父进程没有资源),调用execl()之后父子进程同时运行
vfork()创建的子进程必须用exit()结束

execl()可以用一个新程序代替旧的程序，但是不新建任何进程，如果新的程序正常启动，旧的程序不再继续运行，如果新的程序启动失败，旧程序继续运行
execl(程序所在的路径,命令,命令参数,NULL);
失败返回-1


信号(signal)
信号是Unix/Linux系统中软件中断的最常用的方式
中断是什么？
中断就是中止当前正在执行的代码，转而去执行其他代码。
中断分为软件中断和硬件中断

常见的信号
ctrl+c
段错误
总线错误
整数去除以0
kill -9 发信号9
子进程结束，给父进程发信号

信号本质上是一个非负整数，Unix和Linux在信号上有区别,Unix是48个，Linux是64个，但是中间不保证连续
每一个信号都有一个宏名称，编程时尽量采用宏名称而不是信号的值,不同的系统中，同一个宏名称对应的值可能不同。宏名称以SIG开头
SIGINT  就是信号2的宏名称
查看信号有哪些，可以使用kill命令。发送信号也可以用kill命令。
kill -l:查看所有信号

信号分为可靠信号和不可靠信号，1-31都是不可靠信号,34-64都是可靠信号。不可靠信号不支持排队,如果有多个相同的不可靠信号同时到来时，可能出现信号丢失。可靠信号支持排队，一次不会丢失

信号的处理方式:
1.默认的处理方法 - 系统对每个信号都有默认的处理方法，默认的处理方法大多数都是退出进程
2.忽略信号 - 不作任何处理，就当没有收到信号
3.自定义信号处理函数 - 信号的处理方式改为执行我们自己定义的函数

注意：信号9既不能忽略，也不能自定义处理函数
当前用户只能给当前用户的进程发信号，不能给其他用户发信号，但是root可以给所有进程发信号
信号0没有什么特殊意义，用于测试是否有发信号的权限，kill -0 1111(测试对1111进程是否有发信号的权限)

Unix系统提供了设置信号的处理方式的函数，signal(),sigaction()



