虚拟文件系统
	Linux成功的关键因素之一是它具有与其他操作系统和谐共存的能力。
	虚拟文件系统所隐含的思想是把表示很多不同种类文件系统的共同信息放入内核；其中有一个字段或函数来支持Linux所支持的所有实际文件系统所提供的任何操作。对所调用的每个读写或其他函数，内核都能把它们替换成支持本地Linux文件系统、NTFS文件系统，或者文件所在的任何其他文件系统的实际函数。
	
虚拟文件系统(VFS)的作用
	虚拟文件系统（Virtual Filesystem）也可以称之为虚拟文件系统转换（Virtual Filesystem switch，VFS），是一个内核软件层，用来处理与Unix标准文件系统相关的所有系统调用。其健壮性表现在能为各种文件系统提供一个通用的接口。
	VFS支持的文件系统可以划分为三种主要类型：
		硬盘文件系统：这些文件系统管理在本地磁盘中可用的存储空间或者其他可以起到磁盘作用的设备（比如一个USB闪存）。VFS支持的基于磁盘的某些著名文件系统还有：
			Linux使用的文件系统，Ext2、Ext3及ReiserFS
			Unix家族的文件系统，如sysv文件系统，MINIX文件系统及VERITAS VxFS。
			微软公司的文件系统，如MS-DOS、VFAT及NTFS。
			ISO9660CD-ROM文件系统和通用磁盘格式的DVD文件系统。
			其他有专利权的文件系统，如HPFS、HFS、AFFS以及ADFS。
		网络文件系统：这些文件系统允许轻易地访问属于其他网络计算机的文件系统所包含的文件。虚拟文件系统所支持的一些著名的网络文件系统由：NFS、Coda、AFS、CIFS以及NCP。
		特殊文件系统：这些文件系统不管理本地或者远程磁盘空间。/proc文件系统是特殊文件系统的一个典型范例。
	通用文件模型：
		VFS所隐含的主要思想在与引入了一个通用的文件模型（common file model），这个模型能够表示所有支持的文件系统。该模型严格反映了传统Unix文件系统提供的文件模型。这并不奇怪，因为Linux希望以最小的额外开销运行它的本地文件系统。不过要实现每个具体的文件系统，必须将其物理组织结构转换为虚拟文件系统的通用文件模型。
		从本质上说，Linux内核不能对一个特定的函数进行硬编码来执行诸如read()和ioct()这样的操作，而是对每个操作都必须使用一个指针，指向要访问的具体文件系统的适当函数。
			file->f_op->read(...)
		通用文件模型由下列对象类型组成：
			超级块对象（superblock object）：存放已经安装文件系统的有关信息。对基于磁盘的文件系统，这类对象通常对应于存放在磁盘上的文件系统控制块（filesystem control block）。
			索引节点对象（inode object）：存放关于具体文件的一般信息。对基于磁盘的文件系统，这类对象通常对应于存放在磁盘上的文件控制块（file control block）。
			文件对象（file object）：存放打开文件与进程之间进行交互的有关信息。这类信息仅当进程访问文件期间存在于内核内存中。
			目录项对象（dentry object）：存放目录项（也就是文件的特定名称）与对应文件进行链接的有关信息。每个磁盘文件系统以自己特有的方式将该类信息存在磁盘上。
		进程怎样与文件进行交互：
					fd				f_dentry			d_inode				   i_sb
			进程---------->文件对象-------->目录项对象--------->索引节点对象--------->超级块对象---------->磁盘文件 
		VFS除了能为所有文件系统的实现提供一个通用接口外，还具有另一个与系统性能相关的重要作用。最近最常使用的目录项对象被放在所谓目录项高速缓存（dentry cache）的磁盘高速缓存中，以加速从文件路径名到最后一个路径分量的索引节点的转换过程。
		一般说来，磁盘高速缓存（disk cache）属于软件机制，它允许内核将原本存在磁盘上的某些信息保存在RAM中，以便对这些数据的进一步访问能快速进行，而不必慢速访问磁盘本身。
	VFS所处理的系统调用
		这些系统调用设计文件系统、普通文件、目录文件以及符号链接文件。另外还少数几个由VFS处理的其他系统调用，诸如ioperm(),ioctl(),pipe()和mknod()，涉及设备文件和管道文件。最后一组由VFS处理的系统调用，诸如socket(),connect()和bing()属于套接字系统调用，并用于实现网络功能。
	
VFS的数据结构
	每个VFS对象存放在一个适当的数据结构中，其中包括对象的属性和指向对象方法表的指针。内核可以动态地修改对象的方法，因此可以为对象建立专用的行为。
	超级块对象
		超级块对象由super_block结构组成。
		所有超级块对象都以双向循环链表的形式链接在一起。链表中第一个元素用super_blocks变量来表示，而超级块对象的s_list字段存放指向链表相邻元素的指针。sb_lock自旋锁保护链表免受多处理器系统的同时访问。
		s_fs_info字段指向属于具体文件系统的超级块信息。
		通常为了效率起见，由s_fs_info字段所指向的数据被复制到内存。
	索引节点对象
		文件系统处理文件所需要的所有信息都放在一个名为索引节点的数据结构中。文件名可以随时更改，但是索引节点对文件是唯一的，并且随文件的存在而存在。内存中的索引节点对象由一个inode数据结构组成。
		每个索引节点对象都会复制磁盘索引点包含的一些数据，比如分配给文件的磁盘块数。
		每个索引节点对象总是出现在下列双向循环链表的某个链表中：
			有效未使用的索引节点链表，典型的如哪些镜像有效的磁盘索引节点，且当前未被任何进程使用。
			正在使用的索引节点链表，也就是哪些镜像有效的磁盘索引节点，且当前被某些进程使用。
			脏索引节点链表。
		此外，每个索引节点对象也包含在每文件系统（per-filesystem）的双向循环链表中，链表的头存放在超级块对象的s_inodes字段；缩影节点对象的i_sb_list字段存放了指向链表相邻元素的指针。
	文件对象
		文件对象描述进程怎样与一个打开的文件进行交互。文件对象是在文件被打开时创建的，由一个file结构组成。
		存放在文件对象中的主要信息是文件指针，即文件中当前的位置，下一个操作将在该位置发生。由于几个进程可能同时访问同一个文件，因此文件指针必须存放在文件对象而不是索引节点对象中。
		文件对象通过一个名为filp的slab高速缓存分配，filp描述符地址存放在fulp_cachep变量中。
	目录项对象
		VFS把每个目录看作由若干子目录和文件组成的一个普通文件。
		请注意，目录项对象在磁盘上并没有对应的映像，因此在dentry结构中不包含指出该对象已被修改的字段。
		每个目录对象可以处于以下四种状态之一：
			空闲状态（free）：处于该状态的目录项对象不包含有效的信息，且还没有被VFS使用。
			未使用状态（unused）：处于该状态的目录项对象当前还么有被内核使用。
			正在使用状态（in use）：处于该状态的目录项对象当前正在被内核使用。
			负状态（negative）：与目录项关联的索引节点不复存在，那是因为相应的磁盘索引节点已被删除，或者因为目录项对象是通过解析一个不存在文件的路径被创建的。
	目录项高速缓存
		由于从磁盘读入一个目录项并构造相应的目录项对象需要花费大量的时间，所以在完成对目录项对象的操作后，可能后面还要使用它，因此仍在内存中保留它由重要意义。
		为了更大限度地提高处理这些目录项对象的效率，Linux使用目录项高速缓存，它由两种类型的数据结构组成：
			一个处于正在使用、未使用或负状态的目录项对象的集合。
			一个散列表，从中能够快速获取与给定的文件名和目录名对应的目录项对象。同样，如果访问的对象不再目录项高速缓存中，则散列函数返回一个空值。
		目录项高速缓存的作用相当于索引节点高速缓存（inode cache）的控制器。
	与进程相关的文件
		每个进程都有它自己当前的工作目录和它自己的根目录。这仅仅是内核用来表示进程与文件系统相互作用所必须维护的数据中的两个例子。类型为fs_struct的整个数据结构就用于次目的，且每个进程描述符的fs字段都指向进程的fs_struct结构。
		第二个表表示进程当前打开的文件，表的地址存放于进程描述符files字段。该表的类型为files_struct结构。
		当内核开始使用一个文件对象时，内核提供fget()函数以供调用。这个函数接受文件描述符fd作为参数，返回在current->file->fd[fd]中的地址，即对应文件对象的地址，如果没有任何文件与fd对应，则返回NULL，在第一种强开下，fget()使文件对象引用计数器f_count的值增1。
		当内核控制路径完成对文件对象的使用时，调用内核提供的fput()函数。该函数将文件对象的地址作为参数，并减少文件对象引用计数器f_count的值。
		
文件系统类型
	Linux内核支持很多不同的文件类型。
	文件系统注册------也就是通常在系统初始化期间并且在使用文件系统类型之前必须执行的基本操作。一旦文件系统被注册，其特定的函数对内核就是可用的，因此文件系统类型可以安装在系统的目录树上。
	特殊文件系统
		当网络和磁盘文件系统能够使用户处理存放在内核之外的信息时，特殊文件系统可以为系统程序员和管理员提供一种容易的方式来操作内核的数据结构并实现操作系统的特殊特征。
		下表列出了Linux中所有的最常用的特殊文件系统；对于其中的每个文件系统，表都给出它的安装点和简短介绍。
			注意，有几个文件系统没有固定的安装点（表中的关键词“任意”）。这些文件系统可以由用户自由地安装和使用。
			名字		安装点			说明
			bdev		无				块设备
			binfm1_misc	任意			其他可执行格式
			devpts		/dev/pts		伪终端支持
			eventpollfs	无				由有效时间轮询机制使用
			futexfs		无				由futex（快速用户加锁）机制使用
			pipefs		无				管道
			proc		/proc			对内核数据结构的常规访问点
			rootfs		无				为启动阶段提供一个空的根目录
			shm			无				IPC共享线性区
			mqueue		任意			实现POSIX消息队列时使用
			sockfs		无				套接字
			sysfs		/sys			对系统数据的常规访问点
			tmpfs		任意			临时文件
			usbfs		/proc/bus/usb	USB设备
		特殊文件系统不限于物理块设备。然而，内核给每个安装的特殊文件系统分配一个虚拟的块设备，让其主设备号为0而次设备号具有任意值。
	文件系统类型注册
		通常用户在为自己的系统编译内核时可以把Linux配置位能够识别所有需要的文件系统。但是，文件系统的源代码实际上要么包含在内核镜像中，要么作为一个模块被动态装入。VFS必须对代码目前已在内核中的所有文件系统的类型进行跟踪。这就是通过进行文件系统类型注册来实现的。
		每个注册文件系统都用一个类型为file_system_type的对象来表示。该对象的所有字段如下：
			const char*					name		文件系统名
			int							fs_flags	文件系统类型标志
			struct super_block * (*)()	get_sb		读超级块的方法
			void (*)()					kill_sb		删除超级块的方法
			struct module *				owner		指向实现文件系统的模块的指针
			struct file_system_type *	next		指向文件系统类型链表中下一个元素的指针
			struct list_head			fs_supers	具有相同文件系统类型的超级块对象链表的头
		所有文件系统类型的对象都插入到一个单项链表中。
		在初始化期间，调用register_filesystem()函数注册编译时指定的每个文件系统；该函数把相应的file_system_type对象插入到文件系统类型的链表中。
			int register_filesystem(struct file_system_type * fs)
		当实现了文件系统的模块被装入时，也要调用register_filesystem()函数。在这种情况下，当该模块被卸载时，对应的文件系统页可以被注销（调用unregister_filesystem()函数）。
		get_fs_type()函数（接受文件系统名作为它的参数）扫描已注册的文件系统链表以查找文件系统类型的name字段，并返回指向相应的file_system_type对象（如果存在）的指针。
		
	文件系统处理
		就像每个传统的Unix系统一样，Linux也使用系统的根文件系统（system's root filesystem）；它由内核在应到阶段直接安装，并拥有系统初始化脚本以及最基本的系统程序。
		其他文件系统