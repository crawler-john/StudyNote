IO体系结构和设备驱动程序
	在“I/O体系结构”一节，我们简单考察一下80x86的I/O体系结构。
	在“设备驱动程序模型”一节，我们介绍Linux设备驱动程序模型。
	在“设备文件”一节，我们说明VFS如何把叫做“设备文件”的特殊文件与每个不同的硬件设备相对应，从而使程序可以用相同的方式使用所有的设备文件。
	在“设备驱动程序”一节，我们说明Linux字符设备驱动程序的整体组织结构。

I/O体系结构
	为了确保计算机能够正常工作，必须提供数据通路，让信息在连接到个人计算机的CPU、RAM和I/O设备之间流动。这些数据通路总称总线，担当计算机内部主通信通道作用。
	所有计算机都拥有一条系统总线，它连接大部分内部硬件设备。一种典型的系统总线是PCI（Peripheral Component Interconnect）总线。目前使用其他类型的总线也很多，例如ISA、EISA、MCA、SCSI和USB。
	典型的情况是一台计算机包含几种不同类型的总线，他们通过被称作“桥”的硬件设备连接起来。两条高速总线用于在内存芯片上来回传送数据：
		前端总线将CPU连接到RAM控制器上。
		后端总线将CPU直接连接到外部硬件的高速缓存上。主机上的桥将系统总线和前端总线连接到一起。
	任何I/O设备有且仅能连接一条总线。总线的类型影响I/O设备的内部设计，也影响着内核如何处理设备。
	CPI和I/O设备之间的数据通路称为I/O总线。每个I/O设备依次连接到I/O总线上，这种连接使用了包含3个元素的硬件组织层次：I/O端口、接口和设备控制器。
	
	I/O端口
		每个连接到I/O总线上的设备都有自己的I/O地址集，通常称为I/O端口。在IBM PC体系结构中，I/O地址空间一共提供了65536个8位的I/O接口。可以吧两个连续的8位端口看成一个16位端口，但是必须从偶数地址开始。同理，也可以吧两个连续的16位端口看成一个32位端口，但是必须从4的整数倍地址开始。
		有4条专用的汇编语言质量可以允许CPU对I/O端口进行读写，它们是in、ins、out和outs。在执行其中的一条指令时，CPU使用地址总线选择所请求的I/O端口，使用数据总线在CPU寄存器和端口之间传送数据。
		I/O端口还可以被映射到物理地址空间。因此，处理器和I/O设备之间的通讯就可以使用对内存直接进行操作的汇编语言指令（例如。mov、and、or等等）。现代的硬件设备更倾向于映射的I/O，因为这样处理的速度较快，并可以和DMA结合起来。
		系统设计者的主要目的是对I/O编程提供统一的方法，但又不牺牲性能。为了达到这个目的，每个设备的I/O端口都被组织成一组专用的寄存器。
			CPU把要发送给设备的命令写入设备控制寄存器，并从设备状态寄存器中独处表示设备内部状态的值。CPU还可以通过读取设备输入寄存器的内容从设备取得数据，也可以通过向设备输出寄存器中写入字节而把数据输出到设备。
		为了降低成本，通常把同一I/O端口用于不同的目的。例如，某些位描述设备状态，而某些为指定想设备发出的命令。同理，也可以把同一I/O端口用作输入寄存器和输出寄存器。
		
		访问I/O端口
			in、ins、out和outs汇编语言指令都可以访问I/O端口。内核中包含了一下辅助函数来简化这种访问：
				inb(),inw(),inl():分别从I/O端口读取1,2和4个连续字节。
				inb_p(),inw_p(),inl_p():分别从I/O端口读取1,2和4个连续字节，然后执行一条“哑元（dummy，即空指令）”，指令使CPU暂停。
				outb(),outw(),outl():分别从I/O端口写入1,2和4个连续字节。
				outb_p(),ioutw_p(),outl_p():分别从I/O端口写入1,2和4个连续字节，然后执行一条“哑元（dummy，即空指令）”，指令使CPU暂停。
			资源（resource）表示某个实体的一部分，这部分被互斥地分配给设备驱动程序。在我们的情况中，一个资源表示I/O端口地址的一个范围。每个资源对应的信息存放在resource数据结构中。所有同样资源都插入到一个树型数据结构中；
			任何设备驱动程序都可以使用下面三个函数，传递给它们的参数为资源树的根节点和要插入的新资源数据结构的地址：
				request_resource():把一个给定范围分配给一个I/O设备
				allocate_resource()：在资源树中寻找一个给定大小和排列方式的可用范围；若存在，就将这个范围分配给一个I/O设备。
				release_resource()：释放以前分配给I/O设备的给定范围。
		I/O接口
			I/O接口（I/O interface）是处于一组I/O端口和对应的设备控制器之间的一种硬件电路。它起翻译器的作用，即把I/O端口中的值转换成设备所需要的命令和数据。